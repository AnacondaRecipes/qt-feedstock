Index: qtwebengine/src/3rdparty/chromium/third_party/pdfium/third_party/base/allocator/partition_allocator/address_space_randomization.cc
===================================================================
--- qtwebengine.orig/src/3rdparty/chromium/third_party/pdfium/third_party/base/allocator/partition_allocator/address_space_randomization.cc
+++ qtwebengine/src/3rdparty/chromium/third_party/pdfium/third_party/base/allocator/partition_allocator/address_space_randomization.cc
@@ -16,6 +16,72 @@
 #include <VersionHelpers.h>
 #endif
 
+#if defined(OS_WIN) && !defined(MEMORY_TOOL_REPLACES_ALLOCATOR)
+extern "C" {
+#define VerSetConditionMask myVerSetConditionMask
+
+static ULONGLONG WINAPI VerSetConditionMask(ULONGLONG dwlConditionMask, DWORD dwTypeBitMask, BYTE dwConditionMask)
+{
+    if (dwTypeBitMask == 0)
+	return dwlConditionMask;
+    dwConditionMask &= 0x07;
+    if (dwConditionMask == 0)
+	return dwlConditionMask;
+
+    if (dwTypeBitMask & VER_PRODUCT_TYPE)
+	dwlConditionMask |= dwConditionMask << 7*3;
+    else if (dwTypeBitMask & VER_SUITENAME)
+	dwlConditionMask |= dwConditionMask << 6*3;
+    else if (dwTypeBitMask & VER_SERVICEPACKMAJOR)
+	dwlConditionMask |= dwConditionMask << 5*3;
+    else if (dwTypeBitMask & VER_SERVICEPACKMINOR)
+	dwlConditionMask |= dwConditionMask << 4*3;
+    else if (dwTypeBitMask & VER_PLATFORMID)
+	dwlConditionMask |= dwConditionMask << 3*3;
+    else if (dwTypeBitMask & VER_BUILDNUMBER)
+	dwlConditionMask |= dwConditionMask << 2*3;
+    else if (dwTypeBitMask & VER_MAJORVERSION)
+	dwlConditionMask |= dwConditionMask << 1*3;
+    else if (dwTypeBitMask & VER_MINORVERSION)
+	dwlConditionMask |= dwConditionMask << 0*3;
+    return dwlConditionMask;
+}
+
+typedef LONG (WINAPI* myPFN_RtlVerifyVersionInfoFn)(PRTL_OSVERSIONINFOEXW, ULONG, ULONGLONG);
+
+static BOOL myIsWindows8Point1OrGreater(void)
+{
+	static myPFN_RtlVerifyVersionInfoFn RtlVerifyVersionInfoFn = NULL;
+	if (!RtlVerifyVersionInfoFn)
+	{
+		HMODULE ntdllModule = GetModuleHandleW(L"ntdll.dll");
+		if (ntdllModule)
+		{
+			RtlVerifyVersionInfoFn = (myPFN_RtlVerifyVersionInfoFn)GetProcAddress(ntdllModule, "RtlVerifyVersionInfo");
+		}
+	}
+        if (!RtlVerifyVersionInfoFn)
+           return TRUE;
+	RTL_OSVERSIONINFOEXW versionInfo = { 0 };
+	LONG status;
+	ULONGLONG conditionMask = 0;
+	versionInfo.dwOSVersionInfoSize = sizeof(RTL_OSVERSIONINFOEXW);
+	versionInfo.dwMajorVersion = 6;
+	versionInfo.dwMinorVersion = 3;
+
+	VER_SET_CONDITION(conditionMask, VER_MAJORVERSION, VER_GREATER_EQUAL);
+	VER_SET_CONDITION(conditionMask, VER_MINORVERSION, VER_GREATER_EQUAL);
+
+	status = RtlVerifyVersionInfoFn(&versionInfo,
+		VER_MAJORVERSION | VER_MINORVERSION,
+		conditionMask);
+
+	return (!status ? TRUE : FALSE);
+}
+
+} // extern "C"
+#endif
+
 namespace pdfium {
 namespace base {
 
@@ -33,7 +99,7 @@ void* GetRandomPageBase() {
   static bool windows_81 = false;
   static bool windows_81_initialized = false;
   if (!windows_81_initialized) {
-    windows_81 = IsWindows8Point1OrGreater();
+    windows_81 = myIsWindows8Point1OrGreater();
     windows_81_initialized = true;
   }
   if (!windows_81) {
Index: qtwebengine/src/3rdparty/chromium/v8/src/base/debug/stack_trace_win.cc
===================================================================
--- qtwebengine.orig/src/3rdparty/chromium/v8/src/base/debug/stack_trace_win.cc
+++ qtwebengine/src/3rdparty/chromium/v8/src/base/debug/stack_trace_win.cc
@@ -168,9 +168,34 @@ void DisableSignalStackDump() {
   g_dump_stack_in_signal_handler = false;
 }
 
+extern "C" {
+
+typedef USHORT NTAPI myRtlCaptureStackBackTrace_Function(
+    IN ULONG frames_to_skip,
+    IN ULONG frames_to_capture,
+    OUT PVOID *backtrace,
+    OUT PULONG backtrace_hash);
+
+static int myGetStackTrace_win32(void** result, int max_depth,
+                               int skip_count) {
+  static myRtlCaptureStackBackTrace_Function* myRtlCaptureStackBackTrace_fn;
+  if (!myRtlCaptureStackBackTrace_fn) {
+    myRtlCaptureStackBackTrace_fn = (myRtlCaptureStackBackTrace_Function*)
+    GetProcAddress(GetModuleHandleA("ntdll.dll"), "RtlCaptureStackBackTrace");
+  }
+  if (!myRtlCaptureStackBackTrace_fn) {
+    // TODO(csilvers): should we log an error here?
+    return 0;     // can't find a stacktrace with no function to call
+  }
+  return (int)myRtlCaptureStackBackTrace_fn(skip_count + 3, max_depth,
+                                            result, 0);
+}
+
+}
+
 StackTrace::StackTrace() {
   // When walking our own stack, use CaptureStackBackTrace().
-  count_ = CaptureStackBackTrace(0, arraysize(trace_), trace_, nullptr);
+  count_ = myGetStackBackTrace_win32(trace_, arraysize(trace_),  0);
 }
 
 StackTrace::StackTrace(EXCEPTION_POINTERS* exception_pointers) {
